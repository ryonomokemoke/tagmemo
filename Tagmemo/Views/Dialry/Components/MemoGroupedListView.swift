import SwiftUI

struct MemoGroupedListView: View {
    @ObservedObject var memoStore: MemoStore
    @Binding var selectedTags: Set<String>
    var onEdit: (SavedMemo) -> Void

    @State private var showSecretMemos = false
    @State private var showCompletedTasks = true
    @State private var alertType: AlertType? = nil
    
    // Á∑®ÈõÜÁî®„ÅÆÁä∂ÊÖãÂ§âÊï∞
    @State private var editingMemoId: UUID? = nil
    @State private var editingMemo: SavedMemo = SavedMemo(
        id: UUID(),
        content: "",
        date: Date(),
        tags: []
    )
    @State private var newTag: String = ""
    @FocusState private var isTextFieldFocused: Bool

    enum AlertType: Identifiable {
        case secretConfirmation
        case deleteConfirmation(SavedMemo)
        
        var id: String {
            switch self {
            case .secretConfirmation: return "secret"
            case .deleteConfirmation: return "delete"
            }
        }
    }

    var body: some View {
        NavigationView {
            List {
                ForEach(Array(groupedFilteredMemos.enumerated()), id: \.element.date) { _, group in
                    Section(header: Text(formattedDate(group.date)).font(.headline)) {
                        ForEach(group.entries) { memo in
                            if editingMemoId == memo.id {
                                // „Ç§„É≥„É©„Ç§„É≥Á∑®ÈõÜ„É¢„Éº„Éâ
                                VStack(alignment: .leading, spacing: 12) {
                                    // „É°„É¢ÂÜÖÂÆπ„ÅÆÁ∑®ÈõÜ
                                    TextEditor(text: $editingMemo.content)
                                        .frame(minHeight: 100)
                                        .overlay(
                                            RoundedRectangle(cornerRadius: 8)
                                                .stroke(Color.gray.opacity(0.3), lineWidth: 1)
                                        )
                                    
                                    // „Éà„Ç∞„É´Ë®≠ÂÆö
                                    HStack {
                                        Toggle(isOn: $editingMemo.isSecret) {
                                            HStack {
                                                Image(systemName: "lock")
                                                Text("ÁßòÂØÜ")
                                            }
                                        }
                                        .toggleStyle(SwitchToggleStyle(tint: .orange))
                                        
                                        Toggle(isOn: $editingMemo.isTask) {
                                            HStack {
                                                Image(systemName: "checkmark.square")
                                                Text("„Çø„Çπ„ÇØ")
                                            }
                                        }
                                        .toggleStyle(SwitchToggleStyle(tint: .blue))
                                    }
                                    
                                    if editingMemo.isTask {
                                        Toggle(isOn: $editingMemo.isCompleted) {
                                            HStack {
                                                Image(systemName: "checkmark.circle.fill")
                                                Text("ÂÆå‰∫ÜÊ∏à„Åø")
                                            }
                                        }
                                        .toggleStyle(SwitchToggleStyle(tint: .green))
                                    }
                                    
                                    // ÁèæÂú®„ÅÆ„Çø„Ç∞Ë°®Á§∫
                                    VStack(alignment: .leading, spacing: 4) {
                                        Text("„Çø„Ç∞: \(editingMemo.tags.count)ÂÄã")
                                            .font(.caption)
                                            .foregroundColor(.secondary)
                                        
                                        if !editingMemo.tags.isEmpty {
                                            ScrollView(.horizontal, showsIndicators: false) {
                                                HStack(spacing: 4) {
                                                    ForEach(editingMemo.tags, id: \.self) { tag in
                                                        Button(action: {
                                                            editingMemo.tags.removeAll { $0 == tag }
                                                        }) {
                                                            HStack(spacing: 2) {
                                                                Text(tag)
                                                                    .font(.caption)
                                                                Image(systemName: "xmark.circle.fill")
                                                                    .font(.caption2)
                                                            }
                                                            .padding(.horizontal, 8)
                                                            .padding(.vertical, 4)
                                                            .background(Color.green.opacity(0.3))
                                                            .clipShape(Capsule())
                                                        }
                                                        .buttonStyle(PlainButtonStyle())
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    // „Çø„Ç∞ÂÄôË£úË°®Á§∫
                                    if !newTag.isEmpty && !filteredAvailableTagsForEditing.isEmpty {
                                        VStack(alignment: .leading, spacing: 4) {
                                            Text("üí° „Çø„Ç∞ÂÄôË£ú")
                                                .font(.caption)
                                                .foregroundColor(.blue)
                                            
                                            ScrollView(.horizontal, showsIndicators: false) {
                                                HStack(spacing: 4) {
                                                    ForEach(filteredAvailableTagsForEditing, id: \.self) { tag in
                                                        Button(action: {
                                                            addExistingTag(tag)
                                                        }) {
                                                            Text(tag)
                                                                .font(.caption)
                                                                .padding(.horizontal, 8)
                                                                .padding(.vertical, 4)
                                                                .background(Color.blue.opacity(0.2))
                                                                .clipShape(Capsule())
                                                        }
                                                        .buttonStyle(PlainButtonStyle())
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    
                                    // Êñ∞„Åó„ÅÑ„Çø„Ç∞ËøΩÂä†
                                    HStack {
                                        TextField("Êñ∞„Åó„ÅÑ„Çø„Ç∞", text: $newTag)
                                            .textFieldStyle(RoundedBorderTextFieldStyle())
                                            .focused($isTextFieldFocused)
                                            .font(.caption)
                                        
                                        Button("ËøΩÂä†") {
                                            addNewTag()
                                        }
                                        .font(.caption)
                                        .disabled(newTag.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty)
                                    }
                                    
                                    // ‰øùÂ≠ò„Éª„Ç≠„É£„É≥„Çª„É´„Éú„Çø„É≥
                                    HStack {
                                        Button(action: {
                                            cancelMemoEdit()
                                        }) {
                                            Text("„Ç≠„É£„É≥„Çª„É´")
                                                .padding(.horizontal, 16)
                                                .padding(.vertical, 8)
                                                .background(Color.gray.opacity(0.2))
                                                .foregroundColor(.red)
                                                .cornerRadius(8)
                                        }
                                        .buttonStyle(PlainButtonStyle())
                                        
                                        Spacer()
                                        
                                        Button(action: {
                                            saveMemoEdit()
                                        }) {
                                            Text("‰øùÂ≠ò")
                                                .padding(.horizontal, 16)
                                                .padding(.vertical, 8)
                                                .background(Color.blue)
                                                .foregroundColor(.white)
                                                .cornerRadius(8)
                                        }
                                        .buttonStyle(PlainButtonStyle())
                                    }
                                    .padding(.top, 4)
                                }
                                .padding(.vertical, 8)
                                .contentShape(Rectangle())
                                .onTapGesture { }
                                .listRowInsets(EdgeInsets())
                                .listRowBackground(Color.clear)
                            } else {
                                // ÈÄöÂ∏∏„ÅÆ„É°„É¢Ë°®Á§∫
                                MemoRowView(
                                    memo: memo,
                                    selectedTags: $selectedTags,
                                    onEdit: {
                                        startEditingMemo(memo)
                                    },
                                    onDeleteRequest: {
                                        alertType = .deleteConfirmation(memo)
                                    }
                                )
                            }
                        }
                        .deleteDisabled(editingMemoId != nil)
                    }
                }
            }
            .listStyle(.plain)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    HStack(spacing: 16) {
                        // ÂÆå‰∫ÜÊ∏à„Åø„Çø„Çπ„ÇØË°®Á§∫Âàá„ÇäÊõø„Åà
                        Button(action: {
                            showCompletedTasks.toggle()
                        }) {
                            Image(systemName: showCompletedTasks ? "checkmark.circle.fill" : "checkmark.circle")
                                .foregroundColor(showCompletedTasks ? .green : .gray)
                        }
                        
                        // ÁßòÂØÜ„É°„É¢Ë°®Á§∫Âàá„ÇäÊõø„Åà
                        Button(action: {
                            if showSecretMemos {
                                showSecretMemos = false
                            } else {
                                alertType = .secretConfirmation
                            }
                        }) {
                            Image(systemName: showSecretMemos ? "lock.open" : "lock")
                                .foregroundColor(.gray)
                        }
                    }
                }
                
                ToolbarItem(placement: .keyboard) {
                    if editingMemoId != nil {
                        HStack {
                            Spacer()
                            Button(action: {
                                isTextFieldFocused = false
                                hideKeyboard()
                            }) {
                                Image(systemName: "chevron.down")
                                    .foregroundColor(.blue)
                            }
                        }
                    }
                }
            }
            .alert(item: $alertType) { type in
                switch type {
                case .secretConfirmation:
                    return Alert(
                        title: Text("ÁßòÂØÜ„É°„É¢„ÇíË°®Á§∫„Åó„Åæ„Åô„ÅãÔºü"),
                        message: Text("ÁßòÂØÜÂ±ûÊÄß„ÅÆ„É°„É¢„ÇÇ‰∏ÄË¶ß„Å´Ë°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ"),
                        primaryButton: .default(Text("„ÅØ„ÅÑ")) {
                            showSecretMemos = true
                        },
                        secondaryButton: .cancel()
                    )
                case .deleteConfirmation(let memo):
                    return Alert(
                        title: Text("Êú¨ÂΩì„Å´ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü"),
                        message: Text("„Åì„ÅÆ„É°„É¢„ÅØÂæ©ÂÖÉ„Åß„Åç„Åæ„Åõ„Çì„ÄÇ"),
                        primaryButton: .destructive(Text("ÂâäÈô§")) {
                            memoStore.delete(memo: memo)
                        },
                        secondaryButton: .cancel()
                    )
                }
            }
        }
    }

    private var filteredMemos: [SavedMemo] {
        memoStore.memos.filter { memo in
            // „Çø„Ç∞„Éï„Ç£„É´„Çø„Éº
            let matchesTag = selectedTags.isEmpty || selectedTags.isSubset(of: Set(memo.tags))
            
            // ÁßòÂØÜ„É°„É¢„Éï„Ç£„É´„Çø„Éº
            let passesSecretFilter = showSecretMemos || !memo.isSecret
            
            // ÂÆå‰∫Ü„Çø„Çπ„ÇØ„Éï„Ç£„É´„Çø„Éº
            let passesCompletedTaskFilter = !memo.isTask || showCompletedTasks || !memo.isCompleted
            
            return matchesTag && passesSecretFilter && passesCompletedTaskFilter
        }
    }

    private var groupedFilteredMemos: [(date: Date, entries: [SavedMemo])] {
        let grouped = Dictionary(grouping: filteredMemos) {
            Calendar.current.startOfDay(for: $0.date)
        }
        return grouped.map { ($0.key, $0.value) }
            .sorted { $0.date > $1.date }
    }

    private func formattedDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.locale = Locale(identifier: "ja_JP")
        return formatter.string(from: date)
    }
    
    // Á∑®ÈõÜÈñ¢ÈÄ£„ÅÆ„É°„ÇΩ„ÉÉ„Éâ
    private func startEditingMemo(_ memo: SavedMemo) {
        editingMemoId = memo.id
        editingMemo = memo
        newTag = ""
    }
    
    private func saveMemoEdit() {
        // „Çø„Çπ„ÇØ„Çø„Ç∞„ÅÆËá™ÂãïÁÆ°ÁêÜ„ÇíÂÆüË°å
        var memoToSave = editingMemo
        memoToSave.updateTaskStatus()
        
        // ‰øùÂ≠òÊôÇ„Å´„ÅÆ„ÅøÊõ¥Êñ∞„ÇíÂèçÊò†
        memoStore.update(memo: memoToSave)
        
        // UI„ÇíÊõ¥Êñ∞
        editingMemoId = nil
        editingMemo = SavedMemo(
            id: UUID(),
            content: "",
            date: Date(),
            tags: []
        )
        newTag = ""
    }
    
    private func cancelMemoEdit() {
        // „Ç≠„É£„É≥„Çª„É´ÊôÇ„ÅØ‰Ωï„ÇÇ‰øùÂ≠ò„Åõ„Åö„Å´Á∑®ÈõÜ„É¢„Éº„Éâ„ÇíÁµÇ‰∫Ü
        editingMemoId = nil
        editingMemo = SavedMemo(
            id: UUID(),
            content: "",
            date: Date(),
            tags: []
        )
        newTag = ""
    }
    
    // „Çø„Ç∞Èñ¢ÈÄ£„ÅÆ„É°„ÇΩ„ÉÉ„Éâ
    private var allTags: [String] {
        Array(Set(memoStore.memos.flatMap { $0.tags })).sorted()
    }
    
    private var availableTagsForEditing: [String] {
        allTags.filter { !editingMemo.tags.contains($0) }
    }
    
    private var filteredAvailableTagsForEditing: [String] {
        let trimmed = newTag.trimmingCharacters(in: .whitespacesAndNewlines)
        if trimmed.isEmpty {
            return []
        } else {
            return availableTagsForEditing.filter { $0.localizedCaseInsensitiveContains(trimmed) }
        }
    }
    
    private func addNewTag() {
        let trimmed = newTag.trimmingCharacters(in: .whitespacesAndNewlines)
        if !trimmed.isEmpty && !editingMemo.tags.contains(trimmed) {
            editingMemo.tags.append(trimmed)
        }
        newTag = ""
    }
    
    private func addExistingTag(_ tag: String) {
        if !editingMemo.tags.contains(tag) {
            editingMemo.tags.append(tag)
        }
        newTag = ""
    }
    
    private func hideKeyboard() {
        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
    }
}
